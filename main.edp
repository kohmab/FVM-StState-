load "iovtk";
int[int] Order = [1, 1];
string DataName = "N t", vtkSavePath = "./data/";


real rfdiva = 0.1;
real Epsi = 1;
real nu = 0;

include "./meshes/MeshSphere.idp";
include "Geometry.idp";
include "RusanovFlux.idp";

verbosity=0;

int curplot = 0, plotstep = 10;
real minN = 1e-10;
real dtmin = 1e-1, dt = 1e-16;

//// Poison equation
fespace VhPois(Th, P1);

func real Eps() { return (Th(x, y).region == Th(0, 0).region) ? Epsi : 1.0; }
func real Nplus() { return (Th(x, y).region == Th(0, 0).region) ? 1.0 : 0.0; }

VhPois<real> Ne, Ni = Nplus, Ksi, v;

problem Poison(Ksi, v) = int2d(Th)( Eps() * ( dx(Ksi) * dx(v) + dy(Ksi) * dy(v) ) * x) +
                         int2d(Th)( ( Nplus() - Ne) * v * x) + 
                      on(1, Ksi = 0);



//// Hydrodynamics
func real Velocity(real FluxDens, real Dens) {
  return FluxDens * ((Dens > minN) ? 1. / Dens : 0.);
}

fespace VhHydr(Th, P0);

VhHydr<real> N0 = Nplus(),
         N1,          // electron tensity, "0" - current, "1" - at next step
    Jr0 = 0, Jz0 = 0, // components of
    Jr1 = 0, Jz1 = 0, // the flux density
    PR = N0 ^ (5. / 3.) / 5.,        // preshure
    U0 = N0 ^ (1. / 3.) / sqrt(3.0), // speed of sound
    Er = 0, Ez = 0; // field components

// main cycle

real[int] viso(55);
for (int i = 0; i < 55; i ++)
  viso[i] = 0.02*i;

real T = 0; // current time
while (T < 100) {
  dt = min(hmin / U0[].max / 4 , dtmin);

  for (int t = 0; t < NT; t++) {
    real NL = N0[][t], PRL = PR[][t], U0L = U0[][t];
    real Fn = 0, Fr = 0, Fz = 0; // Fluxes of N, Jr and Jz
    for (int e = 0; e < 3; e++) {
      real JeL = Jr0[][t] * NormalsR(t, e) + Jz0[][t] * NormalsZ(t, e),
           JtL = Jz0[][t] * NormalsR(t, e) - Jr0[][t] * NormalsZ(t, e),
           UeL = Velocity(JeL, NL);
      real NR = 0, JeR = 0, JtR = 0, UeR = 0, PRR = 0, U0R = 0;

      int te = Neighbours(t, e);
      if (te != -1) {
        NR = N0[][te];
        JeR = Jr0[][te] * NormalsR(t, e) + Jz0[][te] * NormalsZ(t, e);
        JtR = Jz0[][te] * NormalsR(t, e) - Jr0[][te] * NormalsZ(t, e);
        UeR = Velocity(JeR, NR);
        PRR = PR[][te];
        U0R = U0[][te];
      } else {
        NR = NL;
        JeR = -JeL;
        JtR = JtL;
        UeR = -UeL;
        PRR = PRL;
        U0R = U0L;
      }
      real maxlam = max(U0R + abs(UeR), U0L + abs(UeL));
      Fn += FluxN * Surfaces(t, e);
      Fr += (FluxJe * NormalsR(t, e) - FluxJt * NormalsZ(t, e)) *
            Surfaces(t, e);
      Fz += (FluxJe * NormalsZ(t, e) + FluxJt * NormalsR(t, e)) *
            Surfaces(t, e);
    }
    N1[][t] = N0[][t] - dt * Fn;
    Jr1[][t] = (1 - nu*dt) * Jr0[][t] + dt * (Er[][t] * N0[][t] - Fr + PRL * Areas[t]);
    Jz1[][t] = (1 - nu*dt) * Jz0[][t] + dt * (Ez[][t] * N0[][t] - Fz);
  }

  while (N1[].min < 0 ) {
    N1[][N1[].imin] = 0;
  }

  N0 = N1;
  Jr0 = Jr1;
  Jz0 = Jz1;

  PR = N0 ^ (5. / 3.) / 5.;
  U0 = N0 ^ (1. / 3.) / sqrt(3.0);

  T += dt;

  Ne = N0;

  Poison;
  Er =  -dx(Ksi) / rfdiva ^ 2;
  Ez =  -dy(Ksi) / rfdiva ^ 2;

  curplot ++;
  if (curplot % plotstep == 0) {
    plot(N0, fill = true, value = true, viso = viso, WindowIndex = 1);
    //plot(Th, Er, fill = true, value = true);
    cout << " T = " << T << endl;
    cout << "Ne = " << 2*pi*int2d(Th)(N0 * x) << endl;
    cout << "dt = " << dt << endl;
    savevtk(vtkSavePath + "N" + curplot / plotstep +  ".vtu", Th, N0, T, dataname=DataName, order=Order);
  }  


}
